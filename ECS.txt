###ECS
#为什么ECS方法比旧OOP方法的速度更快，在OOP方法中，数据不会被组织起来，而是会分散再整个内存中，这是因为使用了自动内存管理功能。
##自动内存管理
#C#内存的分配和释放过程是通过垃圾收集器自动完成的。该过程开始后，Mono平台会从操作系统请求特定容量的内存，并使用该部分内存来生成代码可使用的堆内存空间。
#该堆空间随着代码需要使用更多内存而逐渐增大。如果不再需要之前声明的内存，内存会释放回操作系统，堆的大小也会随之减小，这便是垃圾回收器的工作方式
#此处说法可能和我们熟知的mono内存不会返还操作系统有出入 此处没说 Mono的预分配概念 返还也是返还到预分配内存中
#对于之后的内存分配，如果大小合适的话，垃圾回收器会使用之前用于保存数据并在释放后产生的剩余“间隙”
#因此，将数据从内存移动到缓存需要消耗较多性能，因为必须先找到引用才可以进行移动。
#对于内存管理而言，ECS更加优化，因为ECS的数据会根据类型进行保存，而不是根据数据的分配时间。试想一下，一个商店根据商品的上架顺序放置商品，
#另一个商店根据商品的分类放置商品，你认为哪个商店的做法更好？
#ECS性能更高效的另一个原因是，由于数据已明确地分离出来，ECS只会缓存相关数据。这是什么意思呢？
#当使用OOP时，无论何时访问游戏对象，即使只需要一个特定属性，都必须缓存该对象的所有属性，该做法会对性能产生很大影响，因为缓存这些类型的话，
#会导致原生系统和托管系统之间的交互，而这样做就会产生垃圾，导致垃圾回收的发生。


##https://forum.unity.com/threads/tutorial-unity-ecs-pure-vs-hybrid-including-a-walkthrough.525981/ difference between hybrid and pure ecs

######ECS基本架构
#MonoBehaviour数据对象 挂载于有GameObejctEntity(内置脚本把普通游戏对象转换为实体)脚本的gameobject上 将Monobehaviour自动转为Componnent对象(前提上面有GameObejctEntity标记)
#ComponentSystem行为对象 
#上述两者自动实现绑定 并且行为对象有相应的OnXXXX生命周期接口

####Hybrid(混合) ECS
#自动做了一些依赖收集及维护的工作 隐藏掉部分Lookforcomponentlist的接口的实现细节 例如GetEntities<T> 框架为我们自动做了一些注入依赖 收集容器的工作
#不过看ComponentSystem以及ComponentBase中好多接口 没见过的高级写法等 看的一脸懵逼 有的研究
##文件结构 Components Systems 为了好组织结构如果类名不遵循相应后缀 建议相应结构置于不同的命名空间中 


####Pure ECS
#分工更明细 赋值结构更复杂 控制变复杂了 灵活更像是灾难 who konws